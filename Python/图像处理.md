# 图像处理

```python
'''
    @ 创建时间： 2024 年 12 月 5 日
    @ 创建人： XiaoQi
    @ 项目描述： 本项目主要是利用opencv进行图像处理, 并且封装添加GUI界面。
    @ 网址： https://github.com/ruanjianshi?tab=repositories
    @ 功能： 图像读取 图像变换 图像滤波 图像分割 图像特征提取 图像特征匹配 图像形态学 图像拼接 图像合成 图像显示
    
———————————————————————————————————————————————————————————————————————————————————————————————————————————

    @ 存在问题： (1) 图像拼接上存在问题     
                (2) 图像特征匹配未写 
                
'''
import matplotlib.pyplot as plt
import numpy as np
import cv2
from PIL import Image #Pillow库 读取和显示图像
from PIL import ImageFilter
from PIL import ImageEnhance

#自定义包



#假宏定义，单显示与多显示的开关
Is_LaunchSingle = 1
Is_LaunchMultiple = 0

'''***********************************************图像的读取操作区**************************************'''
image1_PIL = Image.open(r"picture_video\after_matrix\1.png")
image2_PIL = Image.open(r"picture_video\after_matrix\2.png")
image1_CV = cv2.imread(r"picture_video\after_matrix\1.png")
image2_CV = cv2.imread(r"picture_video\after_matrix\2.png")
image3_CV = cv2.imread(r"cv_process\image\lena.png")
image4_CV = cv2.imread(r"cv_process\image\pie.png")
image1_copy = image1_CV.copy()
'''***********************************************图像的读取操作区**************************************'''

'''***********************************************图像的基本操作区**************************************'''
# 调整图像大小
resized_image = image1_PIL.resize((200, 300))
# 翻转图像
flipped_image = image1_PIL.transpose(Image.FLIP_LEFT_RIGHT)
# 旋转图像
rotated_image = image1_PIL.rotate(45)
# 转换图像为灰度图像
gray_image = cv2.cvtColor(np.array(image1_PIL), cv2.COLOR_BGR2GRAY)
gray_image3 = cv2.cvtColor(np.array(image3_CV), cv2.COLOR_BGR2GRAY)
# 转换图像RGB转HSV
HSV_image = cv2.cvtColor(image1_CV,cv2.COLOR_BGR2HSV)
# 将PIL图像转化为NumPy数组
image1PIL_np = np.array(image1_PIL)
image2PIL_np = np.array(image2_PIL)
#将NumPy数组转化为PIL图像
image1_NumPyTOpil = Image.fromarray(image1PIL_np)
image2_NumPyTOpil = Image.fromarray(image2PIL_np)
'''***********************************************图像的基本操作区**************************************'''

'''***********************************************图像的滤波操作区**************************************'''
# 对图像应用高斯模糊滤镜，模糊半径为10
gaussian_blurred_image = image1_PIL.filter(ImageFilter.GaussianBlur(radius=5))
aussian = cv2.GaussianBlur(image3_CV, (5, 5), 1)  # 高斯滤波
# 对图像应用中值滤波器，滤波器大小为5
median_blurred_image = image1_PIL.filter(ImageFilter.MedianFilter(size=5))
median = cv2.medianBlur(image3_CV, 5)  # 中值滤波
#均值滤波   (3, 3)：这个元组指定了卷积核的尺寸
blur = cv2.blur(image3_CV,(3,3))
# 方框滤波  -1: 这个参数表示输出图像的深度  normalize=True: 这个参数指示函数在计算时是否对输出结果进行归一化
box1 = cv2.boxFilter(image3_CV,-1,(3,3), normalize=True)
# 双边滤波
bilater = cv2.bilateralFilter(image3_CV,9,75,75)
# 直方图均衡化
equalized_image = cv2.equalizeHist(gray_image)
'''***********************************************图像的滤波操作区**************************************'''

'''***********************************************图像的增强操作区**************************************'''
# 对比度增强
enhancer = ImageEnhance.Contrast(image1_PIL)
enhanced_image = enhancer.enhance(2)
# 亮度增强
enhancer = ImageEnhance.Brightness(image1_PIL)
enhanced_image = enhancer.enhance(1.5)
'''***********************************************图像的增强操作区**************************************'''

'''***********************************************图像的分割操作区**************************************'''
# 基于阈值的分割
# threshold value:127 max value:255 阈值类型：二值化阈值处理
#THRESH_BINARY THRESH_BINARY_INV THRESH_TOZERO THRESH_TOZERO_INV THRESH_TRUNC THRESH_TRIANGLE THRESH_OTSU
_, thresholded_image = cv2.threshold(gray_image, 127, 255, cv2.THRESH_BINARY) 
# 应用边缘检测
edges = cv2.Canny(gray_image, 100, 200)
'''***********************************************图像的分割操作区**************************************'''

'''***********************************************图像的特征提取操作区**********************************'''
# 应用SIFT特征提取
sift = cv2.SIFT_create()
keypoints, descriptors = sift.detectAndCompute(gray_image, None)
# 显示特征点
image_SIFT_keypoints = cv2.drawKeypoints(image1PIL_np, keypoints, None, flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)  
 
'''***********************************************图像的特征提取操作区**********************************'''

'''***********************************************图像的形态学操作区************************************'''
# 对图像进行形态学操作:腐蚀
kernel_ED = np.ones((30,30),np.uint8) 
erosion_1 = cv2.erode(image4_CV,kernel_ED,iterations = 1)  # 对图像进行一次腐蚀操作
erosion_2 = cv2.erode(image4_CV,kernel_ED,iterations = 2)  # 对图像进行两次腐蚀操作
# 对图像进行形态学操作:膨胀
dilate_1 = cv2.dilate(image4_CV,kernel_ED,iterations = 1)
dilate_2 = cv2.dilate(image4_CV,kernel_ED,iterations = 2)
# 开运算：先腐蚀，再膨胀
kernel_OC = np.ones((5,5),np.uint8) 
opening = cv2.morphologyEx(image4_CV, cv2.MORPH_OPEN, kernel_OC)
# 闭运算：先膨胀，再腐蚀
closing = cv2.morphologyEx(image4_CV, cv2.MORPH_CLOSE, kernel_OC)
# 梯度运算 ：用于提取图像的边缘特征     梯度=膨胀-腐蚀
kernel_G = np.ones((7,7),np.uint8) 
gradient = cv2.morphologyEx(image4_CV, cv2.MORPH_GRADIENT, kernel_G)
# 礼帽 = 原始输入-开运算结果    礼帽 突出了原图像中更亮的局域
kernel_TB = np.ones((7,7),np.uint8) 
tophat = cv2.morphologyEx(image4_CV, cv2.MORPH_TOPHAT, kernel_TB)
# 黑帽 = 闭运算-原始输入    黑帽 突出了原图像中更暗的局域
blackhat  = cv2.morphologyEx(image4_CV,cv2.MORPH_BLACKHAT, kernel_TB)

# 图像梯度-Sobel算子    水平梯度 垂直梯度
# 此函数用于应用Sobel算子进行图像边缘检测
sobelx = cv2.Sobel(gray_image3,cv2.CV_64F,1,0,ksize=3)
sobelx = cv2.convertScaleAbs(sobelx)  # 将Sobel算子输出转换为绝对值并缩放
sobely = cv2.Sobel(gray_image3,cv2.CV_64F,0,1,ksize=3)
sobely = cv2.convertScaleAbs(sobely)  # 将Sobel算子输出转换为绝对值并缩放
# 图像梯度-Scharr算子
scharrx = cv2.Scharr(gray_image3,cv2.CV_64F,1,0)
scharry = cv2.Scharr(gray_image3,cv2.CV_64F,0,1)
scharrx = cv2.convertScaleAbs(scharrx)   
scharry = cv2.convertScaleAbs(scharry)
# 图像梯度-Laplace算子
laplacian = cv2.Laplacian(gray_image3,cv2.CV_64F)
laplacian = cv2.convertScaleAbs(laplacian)
# Canny边缘检测
canny1=cv2.Canny(gray_image3,80,150)
canny2=cv2.Canny(gray_image3,50,100)
# 轮廓检测
# 对灰度图像进行二值化处理，阈值设置为127
ret, binary = cv2.threshold(gray_image,127,255,cv2.THRESH_BINARY)
# 查找轮廓及其层级结构
contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  
# 在原图上绘制找到的轮廓
findcontours_draw = cv2.drawContours(image1_CV,contours,-1,(0,0,255),1)
# 边缘提取
kernel_2D = np.array(([-1,-2,-1],
                   [0,0,0],
                   [1,2,1]))
filter2D = cv2.filter2D(image3_CV,-1,kernel_2D)
'''***********************************************图像的形态学操作区************************************'''

'''***********************************************图像的形状绘制操作区***********************************'''
# 在图像上绘制不同形状和文本
img1 = cv2.line(image1_copy,(10,10),(200,300),(0,0,255),2) 
img2 = cv2.circle(image1_copy,(60,60),30,(0,0,213),-1) 
img3 = cv2.rectangle(image1_copy,(10,10),(100,80),(0,0,200),2) 
img4 = cv2.ellipse(image1_copy,(256,256),(50,40),0,5,360,(20,213,79),-1) 
font=cv2.FONT_HERSHEY_SIMPLEX 
img5 = cv2.putText(image1_copy,'opencv',(80,90), font, 2,(255,255,255),3)
'''***********************************************图像的形状绘制操作区***********************************'''

'''***********************************************图像的拼接与合成操作区********************************'''
# 调整图像大小以匹配
resized_image1_joint = cv2.resize(image1PIL_np, (image2PIL_np.shape[1], image2PIL_np.shape[0]))
# 应用图像合成
image_joint = cv2.addWeighted(image2PIL_np, 1, resized_image1_joint, 1, 0)
#应用图像的拼接
# resized_image1_horizontal = cv2.resize(image1_CV, (image2_CV.shape[0], image2_CV.shape[1]))
image_horizontal = cv2.hconcat([image4_CV,dilate_1,dilate_2]) 
'''***********************************************图像的拼接与合成操作区********************************'''

'''***********************************************图像的显示操作区**************************************'''

'''**********************单显示**********************'''
if Is_LaunchSingle:
    #plt.plot(x, y)
    #plt.title("简单的测试图")
    #plt.xlabel("X轴")
    #plt.ylabel("Y轴")
    plt.imshow(equalized_image)
    plt.axis('off')
    plt.show()
'''**********************单显示**********************'''

'''**********************多显示**********************'''
if Is_LaunchMultiple:
    fig, axs = plt.subplots(2,2,figsize=(10,8))     #创建子图

    axs[0,0].imshow(image1_PIL)
    axs[0,0].set_title('image')
    axs[0,0].axis('off')

    axs[0,1].imshow(flipped_image)
    axs[0,1].set_title('flipped_image')
    axs[0,1].axis('off')

    axs[1,0].imshow(image_SIFT_keypoints)
    axs[1,0].set_title('image_SIFT_keypoints')
    axs[1,0].axis('off')

    axs[1,1].imshow(thresholded_image,cmap='gray')  #cmap='gray': 颜色映射，用于将图像显示为灰度图
    axs[1,1].set_title('thresholded_image')
    axs[1,1].axis('off')

    plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.2)
    plt.tight_layout()
    plt.show()
'''**********************多显示**********************'''
# 图像保存
cv2.imwrite("cv_process/image/canny.png",canny1)
'''***********************************************图像的显示操作区**************************************'''
```

# QT界面设计

```python
import sys
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QPixmap
from PyQt5.QtWidgets import *

class UIDesign(QWidget):
    def __init__(self):
        super().__init__()

        self.setGeometry(400, 200, 800, 600)
        self.setWindowTitle("picture processing")

        # 主布局
        self.main_layout = QVBoxLayout()

        # 图片标签布局
        self.layoutShow = QHBoxLayout()
        self.groupboxShow = QGroupBox("图片显示")
        self.label_origin = QLabel("origin picture", self)
        self.label_origin.setWordWrap(True)
        self.label_origin.setAlignment(Qt.AlignCenter)
        self.label_deal = QLabel("deal picture", self)
        self.label_deal.setWordWrap(True)
        self.label_deal.setAlignment(Qt.AlignCenter)
        self.layoutShow.addWidget(self.label_origin)
        self.layoutShow.addWidget(self.label_deal)
        self.groupboxShow.setLayout(self.layoutShow)
        self.main_layout.addWidget(self.groupboxShow,stretch=2)

        # 添加 QTabWidget
        self.layoutTabH = QHBoxLayout()
        self.tab_widget = QTabWidget()
        self.groupboxTab = QGroupBox("选择区")
        self.tab_widget.addTab(self.Qwidget_Tab1(), "FILTER")
        self.tab_widget.addTab(self.Qwidget_Tab2(), "Tab 2")
        self.layoutTabH.addWidget(self.tab_widget)
        self.groupboxTab.setLayout(self.layoutTabH)
        self.main_layout.addWidget(self.groupboxTab,stretch=1)
        

        # 按钮布局
        self.layoutBtnH = QHBoxLayout()
        self.btn_load_origin = QPushButton("load", self)
        self.btn_load_deal = QPushButton("save", self)
        self.layoutBtnH.addWidget(self.btn_load_origin)
        self.layoutBtnH.addStretch(1)
        self.layoutBtnH.addWidget(self.btn_load_deal)
        


        # 将布局添加到主布局
        self.main_layout.addLayout(self.layoutShow)
        self.main_layout.addLayout(self.layoutBtnH)
        self.main_layout.addLayout(self.layoutTabH)

        # 设置主布局
        self.setLayout(self.main_layout)

        # 连接信号与槽
        self.btn_load_origin.clicked.connect(self.ShowPicture)


    def ShowPicture(self):
        try:
            self.pixmap_origin = QPixmap(r"cv_process\image\lena.png").scaled(300, 300, Qt.KeepAspectRatio)
            self.pixmap_deal = QPixmap(r"cv_process\image\canny.png").scaled(300, 300, Qt.KeepAspectRatio)

            if self.pixmap_origin.isNull():
                raise FileNotFoundError("Original picture not found.")
            if self.pixmap_deal.isNull():
                raise FileNotFoundError("Processed picture not found.")

            self.label_origin.setPixmap(self.pixmap_origin)
            self.label_deal.setPixmap(self.pixmap_deal)

        except FileNotFoundError as e:
            QMessageBox.critical(self, "Error", str(e))
        except Exception as e:
            QMessageBox.critical(self, "Unexpected Error", str(e))

    def Qwidget_Tab1(self):
        self.qwidget1 = QWidget()
        self.layoutTab1 = QHBoxLayout()
        self.btn_tab1 = QPushButton("filter")
        self.btn_tab2 = QPushButton("fil")
        self.btn_tab3 = QPushButton("fi")
        self.layoutTab1.addWidget(self.btn_tab1)
        self.layoutTab1.addWidget(self.btn_tab2)
        self.layoutTab1.addWidget(self.btn_tab3)
        self.qwidget1.setLayout(self.layoutTab1)
        return self.qwidget1

    def Qwidget_Tab2(self):
        self.qwidget2 = QWidget()
        self.layoutTab2 = QGridLayout()

        self.label1 = QLabel("he")
        self.label2 = QLabel("sh")
        self.btn_tab2_1 = QPushButton("world")
        self.btn_tab2_2 = QPushButton("hello")

          # 使用网格布局添加控件
        self.layoutTab2.addWidget(self.label1, 0, 0)  # 第0行，第0列
        self.layoutTab2.addWidget(self.label2, 0, 1)  # 第0行，第1列
        self.layoutTab2.addWidget(self.btn_tab2_1, 1, 0)  # 第1行，第0列
        self.layoutTab2.addWidget(self.btn_tab2_2, 1, 1)  # 第1行，第1列

        self.qwidget2.setLayout(self.layoutTab2)
        return self.qwidget2


def main():
    UIapp = QApplication(sys.argv)
    UI = UIDesign()
    UI.show()
    sys.exit(UIapp.exec_())


if __name__ == '__main__':
    main()
```

# 图片示例

![img](http://qxmapdepot.xiaoq11.cn/picture/lena-1.png)

![img](http://qxmapdepot.xiaoq11.cn/picture/canny.png)

![img](http://qxmapdepot.xiaoq11.cn/picture/pie.png)